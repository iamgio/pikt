package eu.iamgio.pikt.eval

import eu.iamgio.pikt.image.PixelReader
import eu.iamgio.pikt.statement.Statement
import eu.iamgio.pikt.statement.StatementData

/**
 * This class wraps a [Statement] and its own [PixelReader] and represents a queued evaluation process.
 *
 * @param statement queued statement
 * @param reader statement reader
 * @author Giorgio Garofalo
 */
data class QueuedStatement(val statement: Statement, val reader: PixelReader) {

    /**
     * Opens and closes scopes if required.
     * @param scopes mutable list of scopes
     * @param previousStatement the statement that comes before [statement], if exists
     * @param previousPreviousStatement the statement that comes before [previousStatement], if exists
     */
    private fun handleScopes(scopes: MutableList<Scope>, previousStatement: Statement?, previousPreviousStatement: Statement?) {
        // Examples:

        // {        <- opens scope
        //     ...  <- this is in an inner scope
        // }        <- closes scope
        // ...      <- this is in an outer scope

        // if (...) <- no explicit lambda: opens a temporary scope
        //     ...  <- this is in an inner scope
        // ...      <- this is in an outer scope

        if(previousStatement?.options?.closesScope == true || previousPreviousStatement?.options?.opensTemporaryScope == true) {
            scopes.removeLastOrNull() ?: System.err.println("There must be at least one active scope.")
        }
        if(statement.options.opensScope || statement.options.opensTemporaryScope) {
            scopes += Scope(parent = scopes.last(), owner = statement)
        }
    }

    /**
     * Generates output Kotlin code for this [statement].
     * @param scopes mutable list of scopes
     * @param evaluator root evaluator
     * @param previousStatement the statement that comes before [statement], if exists
     * @param nextStatement the statement that comes after [statement], if exists
     * @param previousPreviousStatement the statement that comes before [previousStatement], if exists
     */
    fun eval(scopes: MutableList<Scope>, evaluator: Evaluator, previousStatement: Statement?, nextStatement: Statement?, previousPreviousStatement: Statement?) {
        handleScopes(scopes, previousStatement, previousPreviousStatement)
        val scope = scopes.last()

        // Generate code.
        val code = statement.generate(
                reader = reader,
                syntax = statement.getSyntax(),
                data   = StatementData(scope, previousStatement, nextStatement)
        )

        // Apply indentation.
        evaluator.appendIndentation(scope, statement, previousStatement)

        // Check if the reader has been invalidated and append generated code.
        if(reader.isInvalidated) {
            evaluator.codeBuilder.append("// Output of ${statement.name} was invalidated. See errors for details. ")
            evaluator.codeBuilder.append("This was generated:\n// ") // Output code gets commented out if invalidated.
            evaluator.invalidate()
        }

        // Append the code generated by this statement.
        evaluator.codeBuilder.append(code)

        // Goes to a new line as long as this statement is not followed by a lambda.
        // This allows, for example, `for (...) {` to be on the same line.
        // Without this check, the output would be:
        // for
        // (...) {
        if(nextStatement?.isBlock == false) evaluator.codeBuilder.append("\n")
    }
}

/**
 * Evaluates and generates code for each [QueuedStatement] of this list.
 * @param evaluator root evaluator
 */
fun List<QueuedStatement>.eval(evaluator: Evaluator, mainScope: Scope) {
    val scopes = mutableListOf(mainScope)

    // Each statement generates its own Kotlin code
    forEachIndexed { index, queued ->
        val previousStatement = elementAtOrNull(index - 1)?.statement
        val nextStatement = elementAtOrNull(index + 1)?.statement
        val previousPreviousStatement = elementAtOrNull(index - 2)?.statement
        queued.eval(scopes, evaluator, previousStatement, nextStatement, previousPreviousStatement)
    }

    // Checks if blocks are closed properly. Throws an error otherwise.
    if(scopes.size > 1) {
        // Amount of unclosed scopes.
        val unclosed = scopes.size - (if(lastOrNull()?.statement?.options?.closesScope == true) 2 else 1)
        evaluator.invalidate(message = "$unclosed block${if(unclosed > 1) "s are" else " is"} unclosed. Consider closing lambda blocks.")
    }
}